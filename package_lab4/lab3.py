def task3_1():
    '''
    Дана последовательность целых чисел, 0 - конец последовательности.
    Определить, сколько раз в последовательности меняется знак.
    
    :return counter:
    '''
    counter = 0
    num = 1
    # Если 0, выводим счетчик
    while num != 0:
        num = int(input('Введите число: '))
        if num != abs(num):  # если число не равно модулю числа, то +1 к счетчику
            counter += 1

    return counter


def task3_2():
    '''
    Начав тренировки, спортсмен в первый день пробежал 10км. Каждый день он увеличивал дневную норму на 10% нормы предыдущего дня.
    Какой суммарный путь пробежит спортсмен за 7 дней?
    
    :return distance:
    '''
    first_day = 10
    days = 7
    distance = 0

    # Цикл по дням
    for day in range(1, days + 1):
        # Добавляем дистанцию текущего дня к общей
        distance += first_day
        # Увеличиваем дистанцию на 10% для следующего дня
        first_day *= 1.1

    # Выводим суммарный путь
    return distance


def task3_3(x, eps):
    '''
    Не используя стандартные функции (за исключением abs), вычислить с
    точностью eps > 0 функцию y = ln(1+x). Считать, что требуемая точность достигнута, если очередное
    слагаемое по модулю меньше eps.
    
    :param x: аргумент функции y
    :param eps: точность
    :return: result
    '''

    # Проверяем, что x находится в пределах (-1, 1)
    if abs(x) >= 1:
        print("x должно быть в диапазоне (-1, 1) для ln(1 + x)")
    else:
        term = x  # первое слагаемое
        result = term  # начальное значение результата
        n = 1  # счетчик для слагаемых

        # Цикл для вычисления суммы
        while abs(term) > eps:
            n += 1
            term *= -x / n  # вычисляем следующее слагаемое
            result += term  # добавляем его к результату

        return result

def task3_3_rec(x, eps):
    '''
    С использованием рекурсии
    Не используя стандартные функции (за исключением abs), вычислить с
    точностью eps > 0 функцию y = ln(1+x). Считать, что требуемая точность достигнута, если очередное
    слагаемое по модулю меньше eps.

    :param x: аргумент функции y
    :param eps: точность
    :return: result
    '''
    from math import log

    # Проверяем, что x находится в пределах (-1, 1)
    if abs(x) >= 1:
        print("x должно быть в диапазоне (-1, 1) для ln(1 + x)")
        return None

    def recursive_ln(x, n, term, result):
        # если абсолютное значение терма меньше eps, возвращаем результат
        if abs(term) <= eps:
            return result
        # вычисляем следующее слагаемое и обновляем результат
        term *= -x / n  # вычисляем следующее слагаемое
        result += term  # добавляем его к результату
        return recursive_ln(x, n + 1, term, result)  # рекурсивный вызов

    # Начальные значения
    initial_term = x  # первое слагаемое
    initial_result = initial_term  # начальное значение результата

    # Вызываем рекурсивную функцию
    result = recursive_ln(x, 1, initial_term, initial_result)

    print(f"ln(1 + {x}) = {result}")
    print(f"ln(1 + {x}) = {log(x + 1)}")



